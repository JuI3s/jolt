#![cfg_attr(not(feature = "std"), no_std)]
#![allow(dead_code)]
#![allow(clippy::legacy_numeric_constants)]

#[cfg(not(feature = "std"))]
extern crate alloc;

use itertools::Itertools;
use std::vec;

#[cfg(not(feature = "std"))]
use alloc::{boxed::Box, vec::Vec};

use common::{self, constants::RAM_START_ADDRESS, jolt_device::MemoryConfig};
use emulator::{
    cpu::{self, Xlen},
    default_terminal::DefaultTerminal,
    get_mut_emulator, Emulator, EmulatorState,
};

use instruction::{RV32IMCycle, RV32IMInstruction};
use object::{Object, ObjectSection, SectionKind};

pub mod emulator;
pub mod instruction;

pub use common::jolt_device::JoltDevice;

use crate::emulator::memory::Memory;

/// Executes a RISC-V program and generates its execution trace along with emulator state checkpoints.
///
/// # Details
/// The function performs these steps:
/// 1. Sets up an emulator with the provided program and configuration
/// 2. Runs the program to completion while:
///    - Collecting execution traces of each instruction
///    - Optionally saving periodic checkpoints of the emulator state
///
/// # Arguments
///
/// * `elf_contents`
/// * `inputs`
/// * `memory_config`
/// * `checkpoint_interval` - Number of RV32IMCycle at which to save emulator checkpoints
///                          If None, no checkpoints will be saved
///
/// # Returns
///
/// Returns a tuple containing:
/// * `Vec<RV32IMCycle>` - Complete execution trace
/// * `JoltDevice`
/// * `Option<Vec<LazyTraceIterator>>` - If checkpoint_interval is not None, contains emulator
///                                      checkpoints every n RV32IMCycle. Otherwise None.
///
/// # Example Usage
///
/// let (execution_trace, checkpoints) = trace(elf_contents, inputs, memory_config, Some(5));
///
/// let full_execution_trace = checkpoints.as_ref().unwrap()[0].clone().collect::Vec<RV32IMCycle>();
/// assert!(execution_trace == full_execution_trace);
///
/// let trace_from_checkpoint_1 = checkpoints.as_ref().unwrap()[1].clone().collect::Vec<RV32IMCycle>();
/// assert!(trace_from_checkpoint_1 == execution_trace[n..])
///
/// let trace_from_checkpoint_2 = checkpoints.as_ref().unwrap()[2].clone().collect::Vec<RV32IMCycle>();
/// assert!(trace_from_checkpoint_2 == execution_trace[2*n..])
///
#[tracing::instrument(skip_all)]
pub fn trace(
    elf_contents: Vec<u8>,
    inputs: &[u8],
    memory_config: &MemoryConfig,
) -> (Vec<RV32IMCycle>, Memory, JoltDevice) {
    let mut lazy_trace_iter =
        LazyTraceIterator::new(setup_emulator(elf_contents, inputs, memory_config));
    let trace: Vec<RV32IMCycle> = lazy_trace_iter.by_ref().collect();
    let final_memory_state = std::mem::take(lazy_trace_iter.final_memory_state.as_mut().unwrap());
    (trace, final_memory_state, lazy_trace_iter.get_jolt_device())
}

#[tracing::instrument(skip_all)]
pub fn trace_lazy(
    elf_contents: Vec<u8>,
    inputs: &[u8],
    memory_config: &MemoryConfig,
) -> LazyTraceIterator {
    LazyTraceIterator::new(setup_emulator(elf_contents, inputs, memory_config))
}

#[tracing::instrument(skip_all)]
pub fn trace_checkpoints(
    elf_contents: Vec<u8>,
    inputs: &[u8],
    memory_config: &MemoryConfig,
    checkpoint_interval: usize,
) -> (Vec<std::iter::Take<LazyTraceIterator>>, JoltDevice) {
    let mut emulator_trace_iter =
        LazyTraceIterator::new(setup_emulator(elf_contents, inputs, memory_config));
    let mut checkpoints = Vec::new();

    loop {
        let chkpt = emulator_trace_iter.clone().take(checkpoint_interval);
        checkpoints.push(chkpt);
        emulator_trace_iter = emulator_trace_iter.dropping(checkpoint_interval);
        if emulator_trace_iter.is_empty() {
            break;
        }
    }
    (checkpoints, emulator_trace_iter.get_jolt_device())
}

fn step_emulator(emulator: &mut Emulator, prev_pc: &mut u64, trace: Option<&mut Vec<RV32IMCycle>>) {
    let pc = emulator.get_cpu().read_pc();
    // This is a trick to see if the program has terminated by throwing itself
    // into an infinite loop. It seems to be a good heuristic for now but we
    // should eventually migrate to an explicit shutdown signal.
    if *prev_pc == pc {
        return;
    }
    emulator.tick(trace);
    *prev_pc = pc;
}

#[tracing::instrument(skip_all)]
fn setup_emulator(elf_contents: Vec<u8>, inputs: &[u8], memory_config: &MemoryConfig) -> Emulator {
    let term = DefaultTerminal::default();
    let mut emulator = Emulator::new(Box::new(term));
    emulator.update_xlen(get_xlen());

    let mut jolt_device = JoltDevice::new(memory_config);
    jolt_device.inputs = inputs.to_vec();
    emulator.get_mut_cpu().get_mut_mmu().jolt_device = Some(jolt_device);

    emulator.setup_program(elf_contents);
    emulator
}

/// An iterator that lazily generates execution traces from a RISC-V emulator checkpoint.
///
/// This iterator produces instruction traces one at a time, executing the emulator
/// as needed rather than generating the entire trace upfront. It buffers traces
/// in `current_traces` since some instructions generate multiple trace entries.
/// When the `current_traces` buffer is exhausted, it executes another emulator tick
/// to generate more.
///
/// # Fields
///
/// * `emulator` - Clone of the checkpoint emulator state to execute from
/// * `prev_pc` - Previous program counter value, used for termination detection
/// * `current_traces` - Buffer of trace entries from the most recent emulator tick
#[derive(Clone)]
pub struct LazyTraceIterator {
    emulator_state: EmulatorState,
    prev_pc: u64,
    current_traces: Vec<RV32IMCycle>,
    count: usize, // number of cycles completed
    finished: bool,
    pub(crate) final_memory_state: Option<Memory>,
}

impl LazyTraceIterator {
    pub fn new(emulator_state: EmulatorState) -> Self {
        LazyTraceIterator {
            emulator_state,
            prev_pc: 0,
            current_traces: vec![],
            count: 0,
            finished: false,
            final_memory_state: None,
        }
    }

    pub fn at_tick_boundary(&self) -> bool {
        self.current_traces.is_empty()
    }

    pub fn get_emulator_state(self) -> EmulatorState {
        self.emulator_state
    }

    pub fn clone_emulator_state(&self) -> EmulatorState {
        self.emulator_state.clone()
    }

    pub fn get_jolt_device(self) -> JoltDevice {
        let mut final_emulator_state = self.get_emulator_state();
        final_emulator_state
            .get_mut_cpu()
            .get_mut_mmu()
            .jolt_device
            .take()
            .expect("JoltDevice was not initialized")
    }

    pub fn is_empty(&self) -> bool {
        self.finished
    }
}

impl Iterator for LazyTraceIterator {
    type Item = RV32IMCycle;
    /// Advances the iterator and returns the next trace entry.
    ///
    /// # Returns
    ///
    /// * `Some(RV32IMCycle)` - The next instruction trace in the execution sequence
    /// * `None` - If program execution has completed.
    ///
    /// # Details
    ///
    /// The function follows this sequence:
    /// 1. Returns any remaining traces from the previous emulator tick
    /// 2. If buffer `current_traces` is empty, and the number of ticks
    ///    is not reached, executes another emulator tick``
    /// 3. Checks for program termination using the heuristic of PC not changing
    /// 4. Buffers new traces in FIFO order
    /// 5. Returns the next trace or None if execution is complete
    fn next(&mut self) -> Option<Self::Item> {
        //Iterate over t returning in FIFO order before calling tick() again.
        if !self.current_traces.is_empty() {
            return self.current_traces.pop();
        }

        // Step the emulator to execute the next instruction till the program ends.
        self.count += 1;
        assert!(self.current_traces.is_empty());
        step_emulator(
            get_mut_emulator(&mut self.emulator_state),
            &mut self.prev_pc,
            Some(&mut self.current_traces),
        );
        if self.current_traces.is_empty() {
            self.finished = true;
            // TODO(moodlezoup): Can we take instead of clone?
            self.final_memory_state = Some(self.emulator_state.get_cpu().mmu.memory.memory.clone());
            None
        } else {
            self.current_traces.reverse();
            self.current_traces.pop()
        }
    }
}

fn decode_compressed_to_regular(
    inst: u16,
    _address: u64,
) -> Result<RV32IMInstruction, &'static str> {
    let opcode = inst & 0b11;
    let funct3 = (inst >> 13) & 0b111;

    match opcode {
        0b00 => {
            // Quadrant 0
            match funct3 {
                0b000 => {
                    // C.ADDI4SPN -> addi rd', sp, imm
                    let rd_prime = (((inst >> 2) & 0b111) + 8) as u32;
                    let imm = (((inst >> 11) & 0b11) << 4)
                        | (((inst >> 7) & 0b1111) << 6)
                        | (((inst >> 6) & 0b1) << 2)
                        | (((inst >> 5) & 0b1) << 3);
                    if imm == 0 {
                        return Err("C.ADDI4SPN with imm=0 is reserved");
                    }
                    let expanded = 0b0010011 | (rd_prime << 7) | (2 << 15) | ((imm as u32) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b010 => {
                    // C.LW -> lw rd', offset(rs1')
                    let rd_prime = (((inst >> 2) & 0b111) + 8) as u32;
                    let rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    let offset = (((inst >> 10) & 0b111) << 3)
                        | (((inst >> 6) & 0b1) << 2)
                        | (((inst >> 5) & 0b1) << 6);
                    let expanded = 0b0000011
                        | (rd_prime << 7)
                        | (0b010 << 12)
                        | (rs1_prime << 15)
                        | ((offset as u32) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b011 => {
                    // C.LD -> ld rd', offset(rs1') (RV64 only)
                    let rd_prime = (((inst >> 2) & 0b111) + 8) as u32;
                    let rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    let offset = (((inst >> 10) & 0b111) << 3) | (((inst >> 5) & 0b11) << 6);
                    let expanded = 0b0000011
                        | (rd_prime << 7)
                        | (0b011 << 12)
                        | (rs1_prime << 15)
                        | ((offset as u32) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b110 => {
                    // C.SW -> sw rs2', offset(rs1')
                    let rs2_prime = (((inst >> 2) & 0b111) + 8) as u32;
                    let rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    let offset = (((inst >> 10) & 0b111) << 3)
                        | (((inst >> 6) & 0b1) << 2)
                        | (((inst >> 5) & 0b1) << 6);
                    let imm11_5 = ((offset >> 5) & 0b1111111) as u32;
                    let imm4_0 = (offset & 0b11111) as u32;
                    let expanded = 0b0100011
                        | (imm4_0 << 7)
                        | (0b010 << 12)
                        | (rs1_prime << 15)
                        | (rs2_prime << 20)
                        | (imm11_5 << 25);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b111 => {
                    // C.SD -> sd rs2', offset(rs1') (RV64 only)
                    let rs2_prime = (((inst >> 2) & 0b111) + 8) as u32;
                    let rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    let offset = (((inst >> 10) & 0b111) << 3) | (((inst >> 5) & 0b11) << 6);
                    let imm11_5 = ((offset >> 5) & 0b1111111) as u32;
                    let imm4_0 = (offset & 0b11111) as u32;
                    let expanded = 0b0100011
                        | (imm4_0 << 7)
                        | (0b011 << 12)
                        | (rs1_prime << 15)
                        | (rs2_prime << 20)
                        | (imm11_5 << 25);
                    RV32IMInstruction::decode(expanded, _address)
                }
                _ => Err("Unsupported C0 instruction"),
            }
        }
        0b01 => {
            // Quadrant 1
            match funct3 {
                0b000 => {
                    // C.ADDI -> addi rd, rd, imm
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let imm =
                        ((((inst >> 12) & 0b1) as i32) << 5) | (((inst >> 2) & 0b11111) as i32);
                    let imm = if imm & 0x20 != 0 {
                        imm | 0xFFFFFFC0u32 as i32
                    } else {
                        imm
                    };
                    let expanded =
                        0b0010011 | (rd << 7) | (rd << 15) | ((imm as u32 & 0xFFF) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b001 => {
                    // C.ADDIW -> addiw rd, rd, imm (RV64 only, in RV32 this is C.JAL)
                    // For now, we'll implement C.ADDIW since we're in RV64 mode
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let imm =
                        ((((inst >> 12) & 0b1) as i32) << 5) | (((inst >> 2) & 0b11111) as i32);
                    let imm = if imm & 0x20 != 0 {
                        imm | 0xFFFFFFC0u32 as i32
                    } else {
                        imm
                    };
                    let expanded =
                        0b0011011 | (rd << 7) | (rd << 15) | ((imm as u32 & 0xFFF) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b010 => {
                    // C.LI -> addi rd, x0, imm
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let imm =
                        ((((inst >> 12) & 0b1) as i32) << 5) | (((inst >> 2) & 0b11111) as i32);
                    let imm = if imm & 0x20 != 0 {
                        imm | 0xFFFFFFC0u32 as i32
                    } else {
                        imm
                    };
                    let expanded = 0b0010011 | (rd << 7) | ((imm as u32 & 0xFFF) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b011 => {
                    // C.LUI/C.ADDI16SP
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    if rd == 2 {
                        // C.ADDI16SP -> addi sp, sp, imm
                        let imm = ((((inst >> 6) & 0b1) << 4)
                            | (((inst >> 5) & 0b1) << 5)
                            | (((inst >> 3) & 0b11) << 6)
                            | (((inst >> 2) & 0b1) << 8)
                            | (((inst >> 12) & 0b1) << 9)) as u32;
                        let imm = if imm & 0x200 != 0 {
                            imm | 0xFFFFFC00
                        } else {
                            imm
                        };
                        let expanded = 0b0010011 | (2 << 7) | (2 << 15) | ((imm & 0xFFF) << 20);
                        RV32IMInstruction::decode(expanded, _address)
                    } else {
                        // C.LUI -> lui rd, imm
                        let imm = (((inst >> 2) & 0b11111) as u32) << 12
                            | (((inst >> 12) & 0b1) as u32) << 17;
                        let imm = if imm & 0x20000 != 0 {
                            imm | 0xFFFC0000
                        } else {
                            imm
                        };
                        let expanded = 0b0110111 | (rd << 7) | (imm & 0xFFFFF000);
                        RV32IMInstruction::decode(expanded, _address)
                    }
                }
                0b100 => {
                    // C.SRLI/C.SRAI/C.ANDI/C.SUB/C.XOR/C.OR/C.AND
                    let funct2 = (inst >> 10) & 0b11;
                    let rd_rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    match funct2 {
                        0b00 => {
                            // C.SRLI -> srli rd', rd', shamt
                            let shamt =
                                (((inst >> 2) & 0b11111) | (((inst >> 12) & 0b1) << 5)) as u32;
                            let expanded = 0b0010011
                                | (rd_rs1_prime << 7)
                                | (0b101 << 12)
                                | (rd_rs1_prime << 15)
                                | (shamt << 20);
                            RV32IMInstruction::decode(expanded, _address)
                        }
                        0b01 => {
                            // C.SRAI -> srai rd', rd', shamt
                            let shamt =
                                (((inst >> 2) & 0b11111) | (((inst >> 12) & 0b1) << 5)) as u32;
                            let expanded = 0b0010011
                                | (rd_rs1_prime << 7)
                                | (0b101 << 12)
                                | (rd_rs1_prime << 15)
                                | ((0b010000000000 | shamt) << 20);
                            RV32IMInstruction::decode(expanded, _address)
                        }
                        0b10 => {
                            // C.ANDI -> andi rd', rd', imm
                            let imm = ((inst >> 2) & 0b11111) | (((inst >> 12) & 0b1) << 5);
                            let imm = if imm & 0x20 != 0 {
                                (imm as u32) | 0xFFFFFFC0
                            } else {
                                imm as u32
                            };
                            let expanded = 0b0010011
                                | (rd_rs1_prime << 7)
                                | (0b111 << 12)
                                | (rd_rs1_prime << 15)
                                | ((imm & 0xFFF) << 20);
                            RV32IMInstruction::decode(expanded, _address)
                        }
                        0b11 => {
                            // C.SUB/C.XOR/C.OR/C.AND
                            let funct2_2 = (inst >> 5) & 0b11;
                            let rs2_prime = (((inst >> 2) & 0b111) + 8) as u32;
                            match funct2_2 {
                                0b00 => {
                                    // Check bit 12 for SUB/SUBW
                                    if (inst >> 12) & 0b1 == 0 {
                                        // C.SUB -> sub rd', rd', rs2'
                                        let expanded = 0b0110011
                                            | (rd_rs1_prime << 7)
                                            | (rd_rs1_prime << 15)
                                            | (rs2_prime << 20)
                                            | (0b0100000 << 25);
                                        RV32IMInstruction::decode(expanded, _address)
                                    } else {
                                        // C.SUBW -> subw rd', rd', rs2' (RV64 only)
                                        let expanded = 0b0111011
                                            | (rd_rs1_prime << 7)
                                            | (rd_rs1_prime << 15)
                                            | (rs2_prime << 20)
                                            | (0b0100000 << 25);
                                        RV32IMInstruction::decode(expanded, _address)
                                    }
                                }
                                0b01 => {
                                    // Check bit 12 for XOR/ADDW
                                    if (inst >> 12) & 0b1 == 0 {
                                        // C.XOR -> xor rd', rd', rs2'
                                        let expanded = 0b0110011
                                            | (rd_rs1_prime << 7)
                                            | (0b100 << 12)
                                            | (rd_rs1_prime << 15)
                                            | (rs2_prime << 20);
                                        RV32IMInstruction::decode(expanded, _address)
                                    } else {
                                        // C.ADDW -> addw rd', rd', rs2' (RV64 only)
                                        let expanded = 0b0111011
                                            | (rd_rs1_prime << 7)
                                            | (rd_rs1_prime << 15)
                                            | (rs2_prime << 20);
                                        RV32IMInstruction::decode(expanded, _address)
                                    }
                                }
                                0b10 => {
                                    // C.OR -> or rd', rd', rs2'
                                    let expanded = 0b0110011
                                        | (rd_rs1_prime << 7)
                                        | (0b110 << 12)
                                        | (rd_rs1_prime << 15)
                                        | (rs2_prime << 20);
                                    RV32IMInstruction::decode(expanded, _address)
                                }
                                0b11 => {
                                    // C.AND -> and rd', rd', rs2'
                                    let expanded = 0b0110011
                                        | (rd_rs1_prime << 7)
                                        | (0b111 << 12)
                                        | (rd_rs1_prime << 15)
                                        | (rs2_prime << 20);
                                    RV32IMInstruction::decode(expanded, _address)
                                }
                                _ => unreachable!(),
                            }
                        }
                        _ => unreachable!(),
                    }
                }
                0b101 => {
                    // C.J -> jal x0, offset
                    let offset = ((((inst >> 3) & 0b111) << 1)
                        | (((inst >> 11) & 0b1) << 4)
                        | (((inst >> 2) & 0b1) << 5)
                        | (((inst >> 7) & 0b1) << 6)
                        | (((inst >> 6) & 0b1) << 7)
                        | (((inst >> 9) & 0b11) << 8)
                        | (((inst >> 8) & 0b1) << 10)
                        | (((inst >> 12) & 0b1) << 11)) as u32;
                    let offset = if offset & 0x800 != 0 {
                        (offset | 0xFFFFF000) as i32
                    } else {
                        offset as i32
                    };
                    let imm = ((offset >> 1) & 0x3FF)
                        | (((offset >> 11) & 0x1) << 10)
                        | (((offset >> 12) & 0xFF) << 11)
                        | (((offset >> 20) & 0x1) << 19);
                    let expanded = 0b1101111 | ((imm as u32) << 12);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b110 | 0b111 => {
                    // C.BEQZ/C.BNEZ -> beq/bne rs1', x0, offset
                    let rs1_prime = (((inst >> 7) & 0b111) + 8) as u32;
                    let offset = ((((inst >> 3) & 0b11) << 1)
                        | (((inst >> 10) & 0b11) << 3)
                        | (((inst >> 2) & 0b1) << 5)
                        | (((inst >> 5) & 0b11) << 6)
                        | (((inst >> 12) & 0b1) << 8)) as u32;
                    let offset = if offset & 0x100 != 0 {
                        offset | 0xFFFFFE00
                    } else {
                        offset
                    };
                    let imm11 = (offset >> 11) & 0b1;
                    let imm4_1 = (offset >> 1) & 0b1111;
                    let imm10_5 = (offset >> 5) & 0b111111;
                    let imm12 = (offset >> 12) & 0b1;
                    let imm = (imm11 << 7) | (imm4_1 << 8) | (imm10_5 << 25) | (imm12 << 31);
                    let funct3 = if funct3 == 0b110 { 0b000 } else { 0b001 };
                    let expanded = 0b1100011 | (funct3 << 12) | (rs1_prime << 15) | imm;
                    RV32IMInstruction::decode(expanded, _address)
                }
                _ => unreachable!(),
            }
        }
        0b10 => {
            // Quadrant 2
            match funct3 {
                0b000 => {
                    // C.SLLI -> slli rd, rd, shamt
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let shamt = (((inst >> 2) & 0b11111) | (((inst >> 12) & 0b1) << 5)) as u32;
                    let expanded =
                        0b0010011 | (rd << 7) | (0b001 << 12) | (rd << 15) | (shamt << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b010 => {
                    // C.LWSP -> lw rd, offset(sp)
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let offset = (((inst >> 4) & 0b111) << 2)
                        | (((inst >> 12) & 0b1) << 5)
                        | (((inst >> 2) & 0b11) << 6);
                    let expanded =
                        0b0000011 | (rd << 7) | (0b010 << 12) | (2 << 15) | ((offset as u32) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b011 => {
                    // C.LDSP -> ld rd, offset(sp) (RV64 only)
                    let rd = ((inst >> 7) & 0b11111) as u32;
                    let offset = (((inst >> 5) & 0b1) << 3)
                        | (((inst >> 12) & 0b1) << 4)
                        | (((inst >> 2) & 0b111) << 5);
                    let expanded =
                        0b0000011 | (rd << 7) | (0b011 << 12) | (2 << 15) | ((offset as u32) << 20);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b100 => {
                    let bit12 = (inst >> 12) & 0b1;
                    let rs2 = ((inst >> 2) & 0b11111) as u32;
                    let rs1 = ((inst >> 7) & 0b11111) as u32;
                    if bit12 == 0 && rs2 == 0 {
                        // C.JR -> jalr x0, rs1, 0
                        let expanded = 0b1100111 | (rs1 << 15);
                        RV32IMInstruction::decode(expanded, _address)
                    } else if bit12 == 0 && rs2 != 0 {
                        // C.MV -> add rd, x0, rs2
                        let expanded = 0b0110011 | (rs1 << 7) | (rs2 << 20);
                        RV32IMInstruction::decode(expanded, _address)
                    } else if bit12 == 1 && rs1 == 0 && rs2 == 0 {
                        // C.EBREAK -> ebreak
                        let expanded = 0b1110011 | (0b000000000001 << 20);
                        RV32IMInstruction::decode(expanded, _address)
                    } else if bit12 == 1 && rs2 == 0 {
                        // C.JALR -> jalr x1, rs1, 0
                        let expanded = 0b1100111 | (1 << 7) | (rs1 << 15);
                        RV32IMInstruction::decode(expanded, _address)
                    } else {
                        // C.ADD -> add rd, rd, rs2
                        let expanded = 0b0110011 | (rs1 << 7) | (rs1 << 15) | (rs2 << 20);
                        RV32IMInstruction::decode(expanded, _address)
                    }
                }
                0b110 => {
                    // C.SWSP -> sw rs2, offset(sp)
                    let rs2 = ((inst >> 2) & 0b11111) as u32;
                    let offset = (((inst >> 9) & 0b1111) << 2) | (((inst >> 7) & 0b11) << 6);
                    let imm11_5 = ((offset >> 5) & 0b1111111) as u32;
                    let imm4_0 = (offset & 0b11111) as u32;
                    let expanded = 0b0100011
                        | (imm4_0 << 7)
                        | (0b010 << 12)
                        | (2 << 15)
                        | (rs2 << 20)
                        | (imm11_5 << 25);
                    RV32IMInstruction::decode(expanded, _address)
                }
                0b111 => {
                    // C.SDSP -> sd rs2, offset(sp) (RV64 only)
                    let rs2 = ((inst >> 2) & 0b11111) as u32;
                    let offset = (((inst >> 10) & 0b111) << 3) | (((inst >> 7) & 0b111) << 6);
                    let imm11_5 = ((offset >> 5) & 0b1111111) as u32;
                    let imm4_0 = (offset & 0b11111) as u32;
                    let expanded = 0b0100011
                        | (imm4_0 << 7)
                        | (0b011 << 12)
                        | (2 << 15)
                        | (rs2 << 20)
                        | (imm11_5 << 25);
                    RV32IMInstruction::decode(expanded, _address)
                }
                _ => Err("Unsupported C2 instruction"),
            }
        }
        _ => Err("Invalid compressed instruction opcode"),
    }
}

#[tracing::instrument(skip_all)]
pub fn decode(elf: &[u8]) -> (Vec<RV32IMInstruction>, Vec<(u64, u8)>, Xlen) {
    let obj = object::File::parse(elf).unwrap();
    let mut xlen = Xlen::Bit64;
    if let object::File::Elf32(_) = &obj {
        xlen = Xlen::Bit32;
    }

    let sections = obj
        .sections()
        .filter(|s| s.address() >= RAM_START_ADDRESS)
        .collect::<Vec<_>>();

    let mut instructions = Vec::new();
    let mut data = Vec::new();

    for section in sections {
        let raw_data = section.data().unwrap();

        if let SectionKind::Text = section.kind() {
            let mut offset = 0;
            while offset < raw_data.len() {
                let address = section.address() + offset as u64;

                // Check if we have at least 2 bytes
                if offset + 1 >= raw_data.len() {
                    break;
                }

                // Read first 2 bytes to determine instruction length
                let first_halfword = u16::from_le_bytes([raw_data[offset], raw_data[offset + 1]]);

                // Check if it's a compressed instruction (lowest 2 bits != 11)
                if (first_halfword & 0b11) != 0b11 {
                    // Compressed 16-bit instruction
                    let compressed_inst = first_halfword;

                    // Decode compressed instruction to regular instruction
                    match decode_compressed_to_regular(compressed_inst, address) {
                        Ok(inst) => instructions.push(inst),
                        Err(e) => {
                            eprintln!("Warning: compressed instruction {compressed_inst:04X} at address: {address:08X} failed to decode: {e}");
                            instructions.push(RV32IMInstruction::UNIMPL);
                        }
                    }
                    offset += 2;
                } else {
                    // Standard 32-bit instruction
                    if offset + 3 >= raw_data.len() {
                        eprintln!("Warning: incomplete instruction at address: {address:08X}");
                        break;
                    }

                    let word = u32::from_le_bytes([
                        raw_data[offset],
                        raw_data[offset + 1],
                        raw_data[offset + 2],
                        raw_data[offset + 3],
                    ]);

                    if let Ok(inst) = RV32IMInstruction::decode(word, address) {
                        instructions.push(inst);
                    } else {
                        eprintln!("Warning: word: {word:08X} at address: {address:08X} is not recognized as a valid instruction.");
                        instructions.push(RV32IMInstruction::UNIMPL);
                    }
                    offset += 4;
                }
            }
        }
        let address = section.address();
        for (offset, byte) in raw_data.iter().enumerate() {
            data.push((address + offset as u64, *byte));
        }
    }

    (instructions, data, xlen)
}

fn get_xlen() -> Xlen {
    match common::constants::XLEN {
        32 => cpu::Xlen::Bit32,
        64 => cpu::Xlen::Bit64,
        _ => panic!("Emulator only supports 32 / 64 bit registers."),
    }
}

#[cfg(test)]
mod test {
    use super::*;
    const ELF_CONTENTS: [u8; 6516] = [
        0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2,
        0x0, 0xf3, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x34, 0x0, 0x0, 0x0, 0x6c, 0x17,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x34, 0x0, 0x20, 0x0, 0x4, 0x0, 0x28, 0x0, 0xd, 0x0, 0xc,
        0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x80,
        0x30, 0x4, 0x0, 0x0, 0x30, 0x4, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x1,
        0x0, 0x0, 0x0, 0x30, 0x14, 0x0, 0x0, 0x30, 0x4, 0x0, 0x80, 0x30, 0x4, 0x0, 0x80, 0xf0, 0x0,
        0x0, 0x0, 0xf0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x51, 0xe5, 0x74,
        0x64, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x70, 0xc1, 0x15,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0,
        0x4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x17, 0x11, 0x0, 0x0, 0x13, 0x1, 0x1, 0x43, 0xef, 0x0, 0xc0, 0xb, 0x6f, 0x0, 0x0, 0x0,
        0x13, 0x1, 0x1, 0xff, 0x23, 0x26, 0x11, 0x0, 0x23, 0x24, 0x81, 0x0, 0x13, 0x4, 0x1, 0x1,
        0x37, 0xe5, 0xff, 0x7f, 0x93, 0x5, 0x10, 0x0, 0x23, 0x0, 0xb5, 0x10, 0x6f, 0x0, 0x0, 0x0,
        0x13, 0x1, 0x1, 0xff, 0x23, 0x26, 0x11, 0x0, 0x23, 0x24, 0x81, 0x0, 0x13, 0x4, 0x1, 0x1,
        0x97, 0x0, 0x0, 0x0, 0xe7, 0x80, 0x0, 0xfd, 0x93, 0x7, 0x0, 0x0, 0x93, 0x6, 0x0, 0x0, 0x33,
        0x87, 0xc5, 0x0, 0x93, 0x8, 0xf0, 0xff, 0x93, 0x2, 0x40, 0x0, 0x13, 0x8, 0x50, 0x0, 0x63,
        0x8c, 0x58, 0x4, 0x63, 0x8, 0x6, 0x4, 0x3, 0x83, 0x5, 0x0, 0x93, 0x85, 0x15, 0x0, 0x13,
        0x6, 0xf6, 0xff, 0x93, 0x88, 0x18, 0x0, 0x93, 0x73, 0xf3, 0x7, 0xb3, 0x93, 0xf3, 0x0, 0xb3,
        0xe6, 0xd3, 0x0, 0x93, 0x87, 0x77, 0x0, 0xe3, 0x4c, 0x3, 0xfc, 0x13, 0x6, 0x40, 0x0, 0x63,
        0x98, 0xc8, 0x0, 0x13, 0x76, 0xf3, 0xf, 0x93, 0x7, 0x0, 0x1, 0x63, 0x7e, 0xf6, 0x0, 0x33,
        0x7, 0xb7, 0x40, 0x23, 0x20, 0xd5, 0x0, 0x23, 0x22, 0xb5, 0x0, 0x23, 0x24, 0xe5, 0x0, 0x67,
        0x80, 0x0, 0x0, 0x13, 0x8, 0x40, 0x0, 0x23, 0x0, 0x5, 0x1, 0x23, 0x22, 0x5, 0x0, 0x67,
        0x80, 0x0, 0x0, 0x13, 0x1, 0x1, 0xfe, 0x23, 0x2e, 0x11, 0x0, 0x23, 0x2c, 0x81, 0x0, 0x23,
        0x2a, 0x91, 0x0, 0xb7, 0xc5, 0xff, 0x7f, 0x13, 0x5, 0x81, 0x0, 0x93, 0x85, 0x5, 0x10, 0x37,
        0x16, 0x0, 0x0, 0x97, 0x0, 0x0, 0x0, 0xe7, 0x80, 0x40, 0xf6, 0x83, 0x25, 0xc1, 0x0, 0x63,
        0x8a, 0x5, 0xe, 0x3, 0x24, 0x81, 0x0, 0x3, 0x26, 0x1, 0x1, 0x13, 0x5, 0x81, 0x0, 0x97, 0x0,
        0x0, 0x0, 0xe7, 0x80, 0x80, 0xf4, 0x83, 0x25, 0xc1, 0x0, 0x63, 0x8c, 0x5, 0xc, 0x83, 0x24,
        0x81, 0x0, 0x3, 0x26, 0x1, 0x1, 0x13, 0x5, 0x81, 0x0, 0x97, 0x0, 0x0, 0x0, 0xe7, 0x80,
        0xc0, 0xf2, 0x3, 0x25, 0xc1, 0x0, 0x63, 0xe, 0x5, 0xa, 0x83, 0x27, 0x81, 0x0, 0xb7, 0x5,
        0x0, 0x80, 0x93, 0x85, 0x5, 0x43, 0x37, 0x85, 0xc, 0x0, 0x13, 0x5, 0xe5, 0xc1, 0x13, 0x6,
        0x10, 0x0, 0x73, 0x0, 0x0, 0x0, 0x63, 0x8e, 0x7, 0x8, 0x93, 0x6, 0x0, 0x0, 0x33, 0x86,
        0x84, 0x2, 0x13, 0x7, 0x81, 0x0, 0x33, 0x56, 0xf6, 0x2, 0x23, 0x24, 0xc1, 0x0, 0x83, 0x27,
        0x81, 0x0, 0x13, 0x6, 0x20, 0x0, 0x73, 0x0, 0x0, 0x0, 0x23, 0x24, 0x1, 0x0, 0x23, 0x6, 0x1,
        0x0, 0x13, 0x6, 0x50, 0x0, 0x63, 0x8c, 0xc6, 0x2, 0xb3, 0x5, 0xd7, 0x0, 0x13, 0xd5, 0x77,
        0x0, 0x23, 0x80, 0xf5, 0x0, 0x63, 0xc, 0x5, 0x0, 0x13, 0xe6, 0x7, 0x8, 0x23, 0x80, 0xc5,
        0x0, 0x93, 0x86, 0x16, 0x0, 0x93, 0x7, 0x5, 0x0, 0x6f, 0xf0, 0x9f, 0xfd, 0x13, 0x86, 0x16,
        0x0, 0x37, 0x15, 0x0, 0x0, 0x13, 0x5, 0x15, 0x0, 0x63, 0x7c, 0xa6, 0x2, 0x37, 0xd5, 0xff,
        0x7f, 0x13, 0x5, 0x5, 0x10, 0x93, 0x5, 0x81, 0x0, 0x97, 0x0, 0x0, 0x0, 0xe7, 0x80, 0x0,
        0x3, 0x37, 0xe5, 0xff, 0x7f, 0x93, 0x5, 0x10, 0x0, 0x23, 0x2, 0xb5, 0x10, 0x83, 0x20, 0xc1,
        0x1, 0x3, 0x24, 0x81, 0x1, 0x83, 0x24, 0x41, 0x1, 0x13, 0x1, 0x1, 0x2, 0x67, 0x80, 0x0,
        0x0, 0x97, 0x0, 0x0, 0x0, 0xe7, 0x80, 0xc0, 0xe4, 0x13, 0x1, 0x1, 0xff, 0x23, 0x26, 0x11,
        0x0, 0x23, 0x24, 0x81, 0x0, 0x13, 0x4, 0x1, 0x1, 0x83, 0x20, 0xc1, 0x0, 0x3, 0x24, 0x81,
        0x0, 0x13, 0x1, 0x1, 0x1, 0x17, 0x3, 0x0, 0x0, 0x67, 0x0, 0x83, 0x0, 0x13, 0x1, 0x1, 0xfe,
        0x23, 0x2e, 0x11, 0x0, 0x23, 0x2c, 0x81, 0x0, 0x13, 0x4, 0x1, 0x2, 0x93, 0x6, 0x0, 0x1,
        0x63, 0x60, 0xd6, 0x8, 0xb3, 0x6, 0xa0, 0x40, 0x93, 0xf6, 0x36, 0x0, 0xb3, 0x7, 0xd5, 0x0,
        0x63, 0x74, 0xf5, 0x2, 0x13, 0x87, 0x6, 0x0, 0x13, 0x8, 0x5, 0x0, 0x93, 0x88, 0x5, 0x0,
        0x83, 0xc2, 0x8, 0x0, 0x13, 0x7, 0xf7, 0xff, 0x23, 0x0, 0x58, 0x0, 0x13, 0x8, 0x18, 0x0,
        0x93, 0x88, 0x18, 0x0, 0xe3, 0x16, 0x7, 0xfe, 0xb3, 0x85, 0xd5, 0x0, 0x33, 0x6, 0xd6, 0x40,
        0x13, 0x77, 0xc6, 0xff, 0x93, 0xf8, 0x35, 0x0, 0xb3, 0x86, 0xe7, 0x0, 0x63, 0x94, 0x8, 0x6,
        0x63, 0xfe, 0xd7, 0x0, 0x13, 0x88, 0x5, 0x0, 0x83, 0x28, 0x8, 0x0, 0x23, 0xa0, 0x17, 0x1,
        0x93, 0x87, 0x47, 0x0, 0x13, 0x8, 0x48, 0x0, 0xe3, 0xe8, 0xd7, 0xfe, 0xb3, 0x85, 0xe5, 0x0,
        0x13, 0x76, 0x36, 0x0, 0x33, 0x87, 0xc6, 0x0, 0x63, 0xea, 0xe6, 0x0, 0x6f, 0x0, 0x80, 0x2,
        0x93, 0x6, 0x5, 0x0, 0x33, 0x7, 0xc5, 0x0, 0x63, 0x7e, 0xe5, 0x0, 0x3, 0xc7, 0x5, 0x0,
        0x13, 0x6, 0xf6, 0xff, 0x23, 0x80, 0xe6, 0x0, 0x93, 0x86, 0x16, 0x0, 0x93, 0x85, 0x15, 0x0,
        0xe3, 0x16, 0x6, 0xfe, 0x83, 0x20, 0xc1, 0x1, 0x3, 0x24, 0x81, 0x1, 0x13, 0x1, 0x1, 0x2,
        0x67, 0x80, 0x0, 0x0, 0x13, 0x8, 0x0, 0x0, 0x93, 0x2, 0x40, 0x0, 0x23, 0x2a, 0x4, 0xfe,
        0x33, 0x83, 0x12, 0x41, 0x93, 0x2, 0x44, 0xff, 0x93, 0x73, 0x13, 0x0, 0xb3, 0xe2, 0x12,
        0x1, 0x63, 0x9e, 0x3, 0x4, 0x13, 0x73, 0x23, 0x0, 0x63, 0x14, 0x3, 0x6, 0x83, 0x2e, 0x44,
        0xff, 0x13, 0x98, 0x38, 0x0, 0x93, 0x82, 0x47, 0x0, 0x33, 0x8f, 0x15, 0x41, 0x63, 0xfc,
        0xd2, 0x6, 0xb3, 0x2, 0x0, 0x41, 0x13, 0xfe, 0x82, 0x1, 0x83, 0x22, 0x4f, 0x0, 0x93, 0x3,
        0x4f, 0x0, 0xb3, 0xde, 0xe, 0x1, 0x13, 0x83, 0x47, 0x0, 0x33, 0x9f, 0xc2, 0x1, 0xb3, 0x6e,
        0xdf, 0x1, 0x93, 0x8f, 0x87, 0x0, 0x23, 0xa0, 0xd7, 0x1, 0x93, 0x7, 0x3, 0x0, 0x13, 0x8f,
        0x3, 0x0, 0x93, 0x8e, 0x2, 0x0, 0xe3, 0xea, 0xdf, 0xfc, 0x6f, 0x0, 0x80, 0x4, 0x3, 0xc8,
        0x5, 0x0, 0x23, 0x80, 0x2, 0x1, 0x13, 0x8, 0x10, 0x0, 0x13, 0x73, 0x23, 0x0, 0xe3, 0x0,
        0x3, 0xfa, 0x33, 0x83, 0x5, 0x1, 0x3, 0x13, 0x3, 0x0, 0x33, 0x88, 0x2, 0x1, 0x23, 0x10,
        0x68, 0x0, 0x83, 0x2e, 0x44, 0xff, 0x13, 0x98, 0x38, 0x0, 0x93, 0x82, 0x47, 0x0, 0x33,
        0x8f, 0x15, 0x41, 0xe3, 0xe8, 0xd2, 0xf8, 0x93, 0x82, 0xe, 0x0, 0x93, 0x3, 0xf, 0x0, 0x13,
        0x83, 0x7, 0x0, 0x23, 0x8, 0x4, 0xfe, 0x93, 0x7, 0x10, 0x0, 0x23, 0x7, 0x4, 0xfe, 0x63,
        0x9c, 0xf8, 0x0, 0x93, 0x8, 0x0, 0x0, 0x93, 0x7, 0x0, 0x0, 0x13, 0xe, 0x0, 0x0, 0x93, 0xe,
        0x4, 0xff, 0x6f, 0x0, 0xc0, 0x1, 0x83, 0xc8, 0x43, 0x0, 0x83, 0xc7, 0x53, 0x0, 0x13, 0xe,
        0x20, 0x0, 0x23, 0x8, 0x14, 0xff, 0x93, 0x97, 0x87, 0x0, 0x93, 0xe, 0xe4, 0xfe, 0x13, 0xff,
        0x15, 0x0, 0x63, 0x16, 0xf, 0x0, 0x93, 0x3, 0x0, 0x0, 0x6f, 0x0, 0x0, 0x2, 0x93, 0x83,
        0x43, 0x0, 0xb3, 0x83, 0xc3, 0x1, 0x83, 0xc8, 0x3, 0x0, 0x23, 0x80, 0x1e, 0x1, 0x83, 0x43,
        0xe4, 0xfe, 0x83, 0x48, 0x4, 0xff, 0x93, 0x93, 0x3, 0x1, 0xb3, 0xe8, 0x13, 0x1, 0xb3, 0xd2,
        0x2, 0x1, 0x33, 0x8, 0x0, 0x41, 0xb3, 0xe7, 0x17, 0x1, 0x13, 0x78, 0x88, 0x1, 0xb3, 0x97,
        0x7, 0x1, 0xb3, 0xe7, 0x57, 0x0, 0x23, 0x20, 0xf3, 0x0, 0xb3, 0x85, 0xe5, 0x0, 0x13, 0x76,
        0x36, 0x0, 0x33, 0x87, 0xc6, 0x0, 0xe3, 0xe4, 0xe6, 0xe8, 0x6f, 0xf0, 0xdf, 0xe9, 0x6d,
        0x75, 0x6c, 0x64, 0x69, 0x76, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x7a,
        0x52, 0x0, 0x1, 0x7c, 0x1, 0x1, 0x1b, 0xc, 0x2, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x18, 0x0, 0x0,
        0x0, 0xbc, 0xfb, 0xff, 0xff, 0x20, 0x0, 0x0, 0x0, 0x0, 0x44, 0xe, 0x10, 0x48, 0x81, 0x1,
        0x88, 0x2, 0x44, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0,
        0xbc, 0xfb, 0xff, 0xff, 0x18, 0x0, 0x0, 0x0, 0x0, 0x44, 0xe, 0x10, 0x48, 0x81, 0x1, 0x88,
        0x2, 0x44, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x58, 0x0, 0x0, 0x0, 0xb4,
        0xfb, 0xff, 0xff, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x6c, 0x0,
        0x0, 0x0, 0x1c, 0xfc, 0xff, 0xff, 0x28, 0x1, 0x0, 0x0, 0x0, 0x44, 0xe, 0x20, 0x4c, 0x81,
        0x1, 0x88, 0x2, 0x89, 0x3, 0xa, 0x3, 0x8, 0x1, 0xc1, 0xc8, 0xc9, 0x44, 0xe, 0x0, 0x44, 0xb,
        0x0, 0x24, 0x0, 0x0, 0x0, 0x94, 0x0, 0x0, 0x0, 0x1c, 0xfd, 0xff, 0xff, 0x24, 0x0, 0x0, 0x0,
        0x0, 0x44, 0xe, 0x10, 0x48, 0x81, 0x1, 0x88, 0x2, 0x44, 0xc, 0x8, 0x0, 0xc, 0x2, 0x10,
        0x48, 0xc1, 0xc8, 0x44, 0xe, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0xbc, 0x0, 0x0, 0x0, 0x18,
        0xfd, 0xff, 0xff, 0x20, 0x2, 0x0, 0x0, 0x0, 0x44, 0xe, 0x20, 0x48, 0x81, 0x1, 0x88, 0x2,
        0x44, 0xc, 0x8, 0x0, 0xa, 0x2, 0xa8, 0xc, 0x2, 0x20, 0x48, 0xc1, 0xc8, 0x44, 0xe, 0x0,
        0x44, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4c, 0x69, 0x6e, 0x6b, 0x65, 0x72, 0x3a, 0x20,
        0x4c, 0x4c, 0x44, 0x20, 0x32, 0x30, 0x2e, 0x31, 0x2e, 0x32, 0x20, 0x28, 0x68, 0x74, 0x74,
        0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x72, 0x75, 0x73, 0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x6c, 0x6c, 0x76, 0x6d,
        0x2d, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2e, 0x67, 0x69, 0x74, 0x20, 0x61, 0x39,
        0x38, 0x36, 0x35, 0x63, 0x65, 0x63, 0x61, 0x30, 0x38, 0x31, 0x30, 0x31, 0x30, 0x37, 0x31,
        0x65, 0x32, 0x35, 0x66, 0x33, 0x62, 0x62, 0x61, 0x39, 0x37, 0x62, 0x62, 0x61, 0x38, 0x62,
        0x66, 0x30, 0x65, 0x61, 0x39, 0x37, 0x31, 0x39, 0x29, 0x0, 0x72, 0x75, 0x73, 0x74, 0x63,
        0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x2e, 0x38, 0x38, 0x2e, 0x30,
        0x2d, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x6c, 0x79, 0x20, 0x28, 0x62, 0x38, 0x63, 0x35, 0x34,
        0x64, 0x36, 0x33, 0x35, 0x20, 0x32, 0x30, 0x32, 0x35, 0x2d, 0x30, 0x34, 0x2d, 0x32, 0x30,
        0x29, 0x0, 0x41, 0x29, 0x0, 0x0, 0x0, 0x72, 0x69, 0x73, 0x63, 0x76, 0x0, 0x1, 0x1f, 0x0,
        0x0, 0x0, 0x4, 0x10, 0x5, 0x72, 0x76, 0x33, 0x32, 0x69, 0x32, 0x70, 0x31, 0x5f, 0x6d, 0x32,
        0x70, 0x30, 0x5f, 0x7a, 0x6d, 0x6d, 0x75, 0x6c, 0x31, 0x70, 0x30, 0x0, 0x0, 0x2e, 0x74,
        0x65, 0x78, 0x74, 0x2e, 0x62, 0x6f, 0x6f, 0x74, 0x0, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x2e,
        0x75, 0x6e, 0x6c, 0x69, 0x6b, 0x65, 0x6c, 0x79, 0x2e, 0x5f, 0x5a, 0x4e, 0x34, 0x63, 0x6f,
        0x72, 0x65, 0x39, 0x70, 0x61, 0x6e, 0x69, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x39, 0x70, 0x61,
        0x6e, 0x69, 0x63, 0x5f, 0x66, 0x6d, 0x74, 0x31, 0x37, 0x68, 0x34, 0x30, 0x36, 0x38, 0x30,
        0x31, 0x62, 0x31, 0x35, 0x37, 0x64, 0x35, 0x31, 0x64, 0x31, 0x32, 0x45, 0x0, 0x2e, 0x74,
        0x65, 0x78, 0x74, 0x2e, 0x75, 0x6e, 0x6c, 0x69, 0x6b, 0x65, 0x6c, 0x79, 0x2e, 0x5f, 0x5a,
        0x4e, 0x34, 0x63, 0x6f, 0x72, 0x65, 0x36, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x31, 0x33,
        0x75, 0x6e, 0x77, 0x72, 0x61, 0x70, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x31, 0x37,
        0x68, 0x32, 0x39, 0x64, 0x61, 0x31, 0x38, 0x66, 0x65, 0x61, 0x65, 0x31, 0x31, 0x35, 0x37,
        0x36, 0x30, 0x45, 0x0, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x2e, 0x5f, 0x5a, 0x4e, 0x38, 0x70,
        0x6f, 0x73, 0x74, 0x63, 0x61, 0x72, 0x64, 0x32, 0x64, 0x65, 0x31, 0x35, 0x74, 0x61, 0x6b,
        0x65, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x31, 0x37, 0x68,
        0x33, 0x37, 0x35, 0x33, 0x39, 0x32, 0x64, 0x34, 0x32, 0x36, 0x61, 0x31, 0x31, 0x33, 0x37,
        0x61, 0x45, 0x0, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x2e,
        0x74, 0x65, 0x78, 0x74, 0x2e, 0x6d, 0x65, 0x6d, 0x63, 0x70, 0x79, 0x0, 0x2e, 0x74, 0x65,
        0x78, 0x74, 0x2e, 0x5f, 0x5a, 0x4e, 0x31, 0x37, 0x63, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65,
        0x72, 0x5f, 0x62, 0x75, 0x69, 0x6c, 0x74, 0x69, 0x6e, 0x73, 0x33, 0x6d, 0x65, 0x6d, 0x36,
        0x6d, 0x65, 0x6d, 0x63, 0x70, 0x79, 0x31, 0x37, 0x68, 0x39, 0x65, 0x32, 0x63, 0x62, 0x38,
        0x65, 0x65, 0x66, 0x38, 0x65, 0x63, 0x31, 0x35, 0x63, 0x65, 0x45, 0x0, 0x2e, 0x72, 0x6f,
        0x64, 0x61, 0x74, 0x61, 0x2e, 0x2e, 0x4c, 0x61, 0x6e, 0x6f, 0x6e, 0x2e, 0x30, 0x62, 0x33,
        0x30, 0x33, 0x33, 0x39, 0x32, 0x38, 0x35, 0x38, 0x30, 0x39, 0x38, 0x37, 0x35, 0x66, 0x38,
        0x34, 0x38, 0x62, 0x33, 0x64, 0x35, 0x38, 0x62, 0x61, 0x36, 0x30, 0x61, 0x63, 0x65, 0x2e,
        0x31, 0x38, 0x0, 0x2e, 0x65, 0x68, 0x5f, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x0, 0x2e, 0x63,
        0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x0, 0x2e, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2e, 0x61,
        0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x0, 0x2e, 0x73, 0x68, 0x73, 0x74,
        0x72, 0x74, 0x61, 0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0,
        0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x10, 0x0, 0x0, 0x10, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc,
        0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x80, 0x10, 0x10,
        0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x4c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x30, 0x0,
        0x0, 0x80, 0x30, 0x10, 0x0, 0x0, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6,
        0x0, 0x0, 0x0, 0x48, 0x0, 0x0, 0x80, 0x48, 0x10, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc9, 0x0, 0x0, 0x0,
        0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0xc4, 0x0, 0x0, 0x80, 0xc4, 0x10, 0x0, 0x0, 0x28,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0xd4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0xec, 0x1, 0x0, 0x80,
        0xec, 0x11, 0x0, 0x0, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0,
        0x0, 0x10, 0x2, 0x0, 0x80, 0x10, 0x12, 0x0, 0x0, 0x20, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1d, 0x1, 0x0, 0x0, 0x1, 0x0,
        0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x30, 0x4, 0x0, 0x80, 0x30, 0x14, 0x0, 0x0, 0x6, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50,
        0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x38, 0x4, 0x0, 0x80, 0x38, 0x14,
        0x0, 0x0, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x5a, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x20, 0x15, 0x0, 0x0, 0xa1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x63, 0x1, 0x0, 0x0, 0x3, 0x0, 0x0, 0x70, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc1, 0x15, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x75, 0x1, 0x0, 0x0,
        0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xeb, 0x15, 0x0, 0x0, 0x7f,
        0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0,
    ];
    const INPUTS: [u8; 6] = [0xbd, 0xaa, 0xde, 0x5, 0x11, 0x5c];
    #[test]
    /// Test that the trace function produces the expected number of cycles for a given ELF input.
    /// Test the checkpointing functionality by verifying the number of checkpoints created and
    /// if the traces from checkpoints match the overall execution trace.
    /// The test is based on the muldiv benchmark.
    fn test_trace() {
        use common::jolt_device::MemoryConfig;

        let expected_trace_length = 495;
        let n = 50;
        let (execution_trace, _, _) =
            trace(ELF_CONTENTS.to_vec(), &INPUTS, &MemoryConfig::default());
        let (checkpoints, _) =
            trace_checkpoints(ELF_CONTENTS.to_vec(), &INPUTS, &MemoryConfig::default(), n);
        assert_eq!(execution_trace.len(), expected_trace_length);
        assert_eq!(checkpoints.len(), 10);

        let trace_chunk = execution_trace
            .chunks(n)
            .map(|x| x.to_vec())
            .collect::<Vec<_>>();
        for (i, checkpoint) in checkpoints.into_iter().enumerate() {
            let ti: Vec<RV32IMCycle> = checkpoint.collect();
            assert_eq!(trace_chunk[i], ti);
        }
    }

    #[test]
    fn test_lazy_iterator() {
        let (execution_trace, _, _) =
            trace(ELF_CONTENTS.to_vec(), &INPUTS, &MemoryConfig::default());

        let mut emulator = setup_emulator(ELF_CONTENTS.to_vec(), &INPUTS, &MemoryConfig::default());
        let mut prev_pc: u64 = 0;
        let mut trace = vec![];
        let mut prev_trace_len = 0;
        loop {
            step_emulator(&mut emulator, &mut prev_pc, Some(&mut trace));
            if trace.len() - prev_trace_len == 0 {
                break;
            }
            prev_trace_len = trace.len();
        }
        assert_eq!(execution_trace, trace);
    }
}
